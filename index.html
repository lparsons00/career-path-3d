<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Luke Parsons Portfolio</title>
    <script>
      // CRITICAL: Patch Array methods IMMEDIATELY before any other scripts run
      // This must be the very first script to execute
      // Apply to ALL devices to be safe, but especially mobile
      (function() {
        'use strict';
        
        // Verify patch is applied
        console.log('[PATCH] Applying critical Array/String indexOf patches...');
        
        // Patch Array.indexOf to handle null/undefined - CRITICAL FIX
        const originalIndexOf = Array.prototype.indexOf;
        Array.prototype.indexOf = function(searchElement, fromIndex) {
          try {
            // CRITICAL: Check for null/undefined FIRST (typeof null === 'object' in JS!)
            if (this === null || this === undefined) {
              console.warn('[PATCH] Array.indexOf called on null/undefined, returning -1');
              return -1;
            }
            // Check if it's a primitive (not an object)
            if (typeof this !== 'object' && typeof this !== 'function') {
              console.warn('[PATCH] Array.indexOf called on primitive, returning -1');
              return -1;
            }
            // Try to call original - if it fails, return -1
            return originalIndexOf.call(this, searchElement, fromIndex);
          } catch (e) {
            // If original call fails (e.g., not array-like), return -1
            console.warn('[PATCH] Array.indexOf error, returning -1:', e);
            return -1;
          }
        };
        
        // Patch String.indexOf
        const originalStringIndexOf = String.prototype.indexOf;
        String.prototype.indexOf = function(searchString, position) {
          try {
            // CRITICAL: Check for null/undefined FIRST
            if (this === null || this === undefined) {
              console.warn('[PATCH] String.indexOf called on null/undefined, returning -1');
              return -1;
            }
            // Check if it's actually a string or string-like
            if (typeof this !== 'string' && typeof this !== 'object') {
              console.warn('[PATCH] String.indexOf called on non-string, returning -1');
              return -1;
            }
            return originalStringIndexOf.call(this, searchString, position);
          } catch (e) {
            console.warn('[PATCH] String.indexOf error, returning -1:', e);
            return -1;
          }
        };
        
        // Mobile-specific patches
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
          // Patch WebGL context getShaderPrecisionFormat
          if (typeof WebGLRenderingContext !== 'undefined') {
            const originalGetShaderPrecisionFormat = WebGLRenderingContext.prototype.getShaderPrecisionFormat;
            WebGLRenderingContext.prototype.getShaderPrecisionFormat = function(shaderType, precisionType) {
              try {
                if (!this) {
                  return { rangeMin: 127, rangeMax: 127, precision: 23 };
                }
                if (this.isContextLost && this.isContextLost()) {
                  return { rangeMin: 127, rangeMax: 127, precision: 23 };
                }
                const result = originalGetShaderPrecisionFormat.call(this, shaderType, precisionType);
                return result || { rangeMin: 127, rangeMax: 127, precision: 23 };
              } catch (e) {
                return { rangeMin: 127, rangeMax: 127, precision: 23 };
              }
            };
          }
          
          if (typeof WebGL2RenderingContext !== 'undefined') {
            const originalGetShaderPrecisionFormat2 = WebGL2RenderingContext.prototype.getShaderPrecisionFormat;
            WebGL2RenderingContext.prototype.getShaderPrecisionFormat = function(shaderType, precisionType) {
              try {
                if (!this) {
                  return { rangeMin: 127, rangeMax: 127, precision: 23 };
                }
                if (this.isContextLost && this.isContextLost()) {
                  return { rangeMin: 127, rangeMax: 127, precision: 23 };
                }
                const result = originalGetShaderPrecisionFormat2.call(this, shaderType, precisionType);
                return result || { rangeMin: 127, rangeMax: 127, precision: 23 };
              } catch (e) {
                return { rangeMin: 127, rangeMax: 127, precision: 23 };
              }
            };
          }
        }
        
        // Verify patch is working
        try {
          var testNull = null;
          var testResult = Array.prototype.indexOf.call(testNull, 'test');
          if (testResult === -1) {
            console.log('[PATCH] ✓ Array.indexOf patch verified and working');
          } else {
            console.error('[PATCH] ✗ Array.indexOf patch verification failed');
          }
        } catch (e) {
          console.error('[PATCH] ✗ Array.indexOf patch verification error:', e);
        }
        
        // Install global error handler to catch indexOf errors on null
        // This catches errors that happen before the patch can intercept
        if (typeof window !== 'undefined') {
          var originalOnerror = window.onerror;
          window.onerror = function(msg, url, line, col, error) {
            // Check if this is an indexOf error on null
            if (msg && typeof msg === 'string' && 
                (msg.includes('indexOf') || msg.includes('l.indexOf') || msg.includes('null is not an object'))) {
              console.warn('[PATCH] Caught indexOf error on null, suppressing:', msg);
              // Suppress the error - return true to prevent default handling
              return true;
            }
            // For other errors, call original handler if it exists
            if (originalOnerror) {
              return originalOnerror.call(this, msg, url, line, col, error);
            }
            return false;
          };
          
          // Also catch unhandled promise rejections
          window.addEventListener('unhandledrejection', function(event) {
            var reason = event.reason;
            var errorMsg = reason && (reason.message || reason.toString() || '');
            if (errorMsg && typeof errorMsg === 'string' && 
                (errorMsg.includes('indexOf') || errorMsg.includes('null is not an object'))) {
              console.warn('[PATCH] Caught indexOf rejection, suppressing:', errorMsg);
              event.preventDefault(); // Suppress the error
            }
          });
        }
      })();
    </script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>